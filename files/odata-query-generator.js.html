<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>odata-query-generator.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/BooleanFilterOptions.html">BooleanFilterOptions</a></li>
                                <li><a href="../classes/DateTimeFilterOptions.html">DateTimeFilterOptions</a></li>
                                <li><a href="../classes/FilterOptions.html">FilterOptions</a></li>
                                <li><a href="../classes/FloatingPointFilterOptions.html">FloatingPointFilterOptions</a></li>
                                <li><a href="../classes/GuidFilterOptions.html">GuidFilterOptions</a></li>
                                <li><a href="../classes/IntegerFilterOptions.html">IntegerFilterOptions</a></li>
                                <li><a href="../classes/NullFilterOptions.html">NullFilterOptions</a></li>
                                <li><a href="../classes/QueryBuilder.html">QueryBuilder</a></li>
                                <li><a href="../classes/StringFilterOptions.html">StringFilterOptions</a></li>
                                <li><a href="../classes/WhereFilterOptions.html">WhereFilterOptions</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/OData.html">OData</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: odata-query-generator.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * The OData module is designed to generate OData query strings for specific
 * API endpoints. General usage is as follows.
 *
 * &lt;pre&gt;
 * var qb = new OData.QueryBuilder(&#x27;/api/users&#x27;);
 * qb.addWhereFilter(&#x27;id1&#x27;, OData.STRING, &#x27;fName&#x27;, OData.EQUALS, &#x27;Bartholomew&#x27;);
 * var query = qb.generateQueryUrl(); // query would equal &quot;/api/users/?$filter=fName eq &#x27;Bartholomew&#x27;&quot;
 * &lt;/pre&gt;
 *
 * The OData object provides the following constants for use with &#x60;QueryBuilder.addWhereFilter()&#x60;.
 * &lt;br/&gt;
 * Filter types:
 * - OData.NULL
 * - OData.BOOLEAN
 * - OData.DECIMAL
 * - OData.SINGLE
 * - OData.DOUBLE
 * - OData.BYTE
 * - OData.SBYTE
 * - OData.INT16
 * - OData.INT32
 * - OData.INT64
 * - OData.TIME
 * - OData.DATE_TIME
 * - OData.DATE_TIME_OFFSET
 * - OData.GUID
 * - OData.STRING
 *
 * Query Operators:
 * - OData.IS_TRUE
 * - OData.IS_FALSE
 * - OData.ROUND_EQUALS
 * - OData.FLOOR_EQUALS
 * - OData.CEILING_EQUALS
 * - OData.EQUALS
 * - OData.NOT_EQUALS
 * - OData.GREATER_THAN
 * - OData.GREATER_THAN_OR_EQUAL_TO
 * - OData.LESS_THAN
 * - OData.LESS_THAN_OR_EQUAL_TO
 * - OData.BEFORE
 * - OData.AFTER
 * - OData.YEAR_EQUALS
 * - OData.MONTH_NUMBER_EQUALS
 * - OData.DAY_NUMBER_EQUALS
 * - OData.HOUR_EQUALS
 * - OData.MINUTE_EQUALS
 * - OData.SECOND_EQUALS
 * - OData.IN_SEMICOLON_SEPARATED
 * - OData.CASE_INSENSITIVE_EQUALS
 * - OData.CASE_INSENSITIVE_NOT_EQUALS
 * - OData.STARTS_WITH
 * - OData.DOES_NOT_START_WITH
 * - OData.ENDS_WITH
 * - OData.DOES_NOT_END_WITH
 * - OData.CONTAINS
 * - OData.HAS_LENGTH
 *
 * The OData object provides the following constants for use with &#x60;QueryBuilder.setOrderBy()&#x60;.
 * &lt;br/&gt;
 * OrderBy Orders:
 * - OData.NONE
 * - OData.ASC
 * - OData.DESC
 *
 * @module OData
 */
 define(function() {
  var OData = {};

  // ----------------------------------------------------------------------------
  //    Constants
  // ----------------------------------------------------------------------------
  // Filter types
  OData.NULL = &#x27;NULL&#x27;;
  OData.BOOLEAN = &#x27;BOOLEAN&#x27;;
  OData.DECIMAL = &#x27;DECIMAL&#x27;;
  OData.SINGLE = &#x27;SINGLE&#x27;;
  OData.DOUBLE = &#x27;DOUBLE&#x27;;
  OData.BYTE = &#x27;BYTE&#x27;;
  OData.SBYTE = &#x27;SBYTE&#x27;;
  OData.INT16 = &#x27;INT16&#x27;;
  OData.INT32 = &#x27;INT32&#x27;;
  OData.INT64 = &#x27;INT64&#x27;;
  OData.TIME = &#x27;TIME&#x27;;
  OData.DATE_TIME = &#x27;DATE_TIME&#x27;;
  OData.DATE_TIME_OFFSET = &#x27;DATE_TIME_OFFSET&#x27;;
  OData.GUID = &#x27;GUID&#x27;;
  OData.STRING = &#x27;STRING&#x27;;
  // Query Operators
  OData.IS_TRUE = &#x27;IS_TRUE&#x27;;
  OData.IS_FALSE = &#x27;IS_FALSE&#x27;;
  OData.ROUND_EQUALS = &#x27;ROUND_EQUALS&#x27;;
  OData.FLOOR_EQUALS = &#x27;FLOOR_EQUALS&#x27;;
  OData.CEILING_EQUALS = &#x27;CEILING_EQUALS&#x27;;
  OData.EQUALS = &#x27;EQUALS&#x27;;
  OData.NOT_EQUALS = &#x27;NOT_EQUALS&#x27;;
  OData.GREATER_THAN = &#x27;GREATER_THAN&#x27;;
  OData.GREATER_THAN_OR_EQUAL_TO = &#x27;GREATER_THAN_OR_EQUAL_TO&#x27;;
  OData.LESS_THAN = &#x27;LESS_THAN&#x27;;
  OData.LESS_THAN_OR_EQUAL_TO = &#x27;LESS_THAN_OR_EQUAL_TO&#x27;;
  OData.BEFORE = &#x27;BEFORE&#x27;;
  OData.AFTER = &#x27;AFTER&#x27;;
  OData.YEAR_EQUALS = &#x27;YEAR_EQUALS&#x27;;
  OData.MONTH_NUMBER_EQUALS = &#x27;MONTH_NUMBER_EQUALS&#x27;;
  OData.DAY_NUMBER_EQUALS = &#x27;DAY_NUMBER_EQUALS&#x27;;
  OData.HOUR_EQUALS = &#x27;HOUR_EQUALS&#x27;;
  OData.MINUTE_EQUALS = &#x27;MINUTE_EQUALS&#x27;;
  OData.SECOND_EQUALS = &#x27;SECOND_EQUALS&#x27;;
  OData.IN_SEMICOLON_SEPARATED = &#x27;IN_SEMICOLON_SEPARATED&#x27;;
  OData.CASE_INSENSITIVE_EQUALS = &#x27;CASE_INSENSITIVE_EQUALS&#x27;;
  OData.CASE_INSENSITIVE_NOT_EQUALS = &#x27;CASE_INSENSITIVE_NOT_EQUALS&#x27;;
  OData.STARTS_WITH = &#x27;STARTS_WITH&#x27;;
  OData.DOES_NOT_START_WITH = &#x27;DOES_NOT_START_WITH&#x27;;
  OData.ENDS_WITH = &#x27;ENDS_WITH&#x27;;
  OData.DOES_NOT_END_WITH = &#x27;DOES_NOT_END_WITH&#x27;;
  OData.CONTAINS = &#x27;CONTAINS&#x27;;
  OData.HAS_LENGTH = &#x27;HAS_LENGTH&#x27;;
  // OrderBy Orders
  OData.NONE = 0;
  OData.ASC = 1;
  OData.DESC = 2;

  /**
   * Extend the built in String class with a format function.
   * @private
   * @method format
   */
  if (!String.prototype.format) {
    String.prototype.format = function() {
      var args = arguments;
      return this.replace(/{(\d+)}/g, function(match, number) {
        return typeof args[number] !== &#x27;undefined&#x27; ? args[number] : match;
      });
    };
  }

  /**
   * Gives the child object a copy of the parent object&#x27;s prototype.
   * @private
   * @method _extend
   * @param base {Function} The base method whose prototype will be copied.
   * @param child {Function} The child method who will get a copy of the parent&#x27;s prototype.
   * @return {Function} The augmented child method.
   */
  OData._extend = function(base, child) {
    child.prototype = new base();
    child.prototype.constructor = child;
    child.base = base.prototype;
    return child;
  };

  /**
   * Make sure there is a trailing /.
   * @private
   * @method _cleanEndpointUrl
   * @param url {String} The endpoint url.
   * @return {String} The cleaned endpoint url.
   */
  OData._cleanEndpointUrl = function(url) {
    if (url[url.length - 1] !== &#x27;/&#x27;) {
      url += &#x27;/&#x27;;
    }
    return url;
  };


  // ------------------------------------------------------------------------------
  // The filters used to make meaningful queries to the service.
  // ------------------------------------------------------------------------------
  /**
   * Where clause filter options base class.
   * @class FilterOptions
   * @constructor
   */
  OData.FilterOptions = function() {
    this.options = {
      encodeUrlComponents: false
    };
    this.values = [];
  };

  /**
   * Where clause filter base class init method.
   * @method init
   * @param options {Object} Options to set on each where filter.
   */
  OData.FilterOptions.prototype.init = function(options) {
    for (var name in options) {
      this.options[name] = options[name];
    }
  };

  /**
   * Base query string for each type of filter.
   * @method getWhereQuery
   * @param propNames {Array|String} The list of property names.
   * @param operator {String} The comparator for this filter.
   * @param value {Array|String} The value of the property.
   * @return {String} The query string for the specified where filter.
   */
  OData.FilterOptions.prototype.getWhereQuery = function(propNames, operator, values) {
    var i,
        l,
        finalQuery = [],
        filter = this.values[operator],
        query = &#x27;&#x27;;
    if (propNames &amp;&amp; values !== undefined &amp;&amp; values !== null) {
      if (Array.isArray(propNames) &amp;&amp; Array.isArray(values)) {
        if (propNames.length &gt; values.length) {
          // Too many properties, truncate to match values
          propNames.splice(values.length, propNames.length);
        }
        if (values.length &gt; propNames.length) {
          // Too many values, truncate to match properties
          values.splice(propNames.length, values.length);
        }
        for(i=0, l=propNames.length; i &lt; l; i++) {
          finalQuery.push(filter.stringFormat.format(propNames[i], values[i]));
        }
        query = finalQuery.join(&#x27; or &#x27;);
      } else if (Array.isArray(propNames) || Array.isArray(values)) {
        // Is propNames an array
        if (Array.isArray(propNames)) {
          // make all the props match the one value
          for(i=0, l=propNames.length; i &lt; l; i++) {
           finalQuery.push(filter.stringFormat.format(propNames[i], values));
          }
        } else {
          // make all the values match the one propertyName
          for(i=0, l=values.length; i &lt; l; i++) {
            finalQuery.push(filter.stringFormat.format(propNames, values[i]));
          }
        }
        query = finalQuery.join(&#x27; or &#x27;);
      } else {
        // We have only one property/value.
        query = filter.stringFormat.format(propNames, values);
      }
    }
    return query;
  };

  /**
   * Null where clause filter class.
   * @class NullFilterOptions
   * @extends FilterOptions
   * @param options {Object} The options object.
   */
  OData.NullFilterOptions = OData._extend(OData.FilterOptions, function(options) {
    this.init(options);
    this.values = [
      { errorMessage: &#x27;You are not able to query on this property.&#x27; }
    ];
  });

  /**
   * Gets the where query, which for null is an empty string.
   * @method getWhereQuery
   * @return {String} An empty string.
   */
  OData.NullFilterOptions.prototype.getWhereQuery = function() {
    return &#x27;&#x27;;
  };

  /**
   * Boolean where clause filter class.
   * @class BooleanFilterOptions
   * @extends FilterOptions
   * @param options {Object} The options object.
   */
  OData.BooleanFilterOptions = OData._extend(OData.FilterOptions, function(options) {
    this.init(options);
    this.values = {
      &#x27;IS_TRUE&#x27;:  { stringFormat: &#x27;{0} eq true&#x27;  },
      &#x27;IS_FALSE&#x27;: { stringFormat: &#x27;{0} eq false&#x27; }
    };
  });

  /**
   * Gets the where query for Boolean objects.
   * @method getWhereQuery
   * @param propNames {Array|String} The list of property names.
   * @param operator {String} The type of comparator to perform.
   * @return {String} A Boolean query string.
   */
  OData.BooleanFilterOptions.prototype.getWhereQuery = function(propNames, operator) {
    return OData.BooleanFilterOptions.base.getWhereQuery.call(
      this, propNames, operator, &#x27;&#x27;);
  };

  /**
   * FloatingPoint where clause filter class.
   * @class FloatingPointFilterOptions
   * @extends FilterOptions
   * @param options {Object} The options object.
   */
  OData.FloatingPointFilterOptions = OData._extend(OData.FilterOptions, function(options) {
    this.init(options);
    this.values = {
      &#x27;ROUND_EQUALS&#x27;:             { stringFormat: &#x27;round({0}) eq {1}&#x27;   },
      &#x27;FLOOR_EQUALS&#x27;:             { stringFormat: &#x27;floor({0}) eq {1}&#x27;   },
      &#x27;CEILING_EQUALS&#x27;:           { stringFormat: &#x27;ceiling({0}) eq {1}&#x27; },
      &#x27;EQUALS&#x27;:                   { stringFormat: &#x27;{0} eq {1}&#x27;          },
      &#x27;NOT_EQUALS&#x27;:               { stringFormat: &#x27;{0} ne {1}&#x27;          },
      &#x27;GREATER_THAN&#x27;:             { stringFormat: &#x27;{0} gt {1}&#x27;          },
      &#x27;GREATER_THAN_OR_EQUAL_TO&#x27;: { stringFormat: &#x27;{0} ge {1}&#x27;          },
      &#x27;LESS_THAN&#x27;:                { stringFormat: &#x27;{0} lt {1}&#x27;          },
      &#x27;LESS_THAN_OR_EQUAL_TO&#x27;:    { stringFormat: &#x27;{0} le {1}&#x27;          }
    };
  });

  /**
   * Integer where clause filter class.
   * @class IntegerFilterOptions
   * @extends FilterOptions
   * @param options {Object} The options object.
   */
  OData.IntegerFilterOptions = OData._extend(OData.FilterOptions, function(options) {
    this.init(options);
    this.values = {
      &#x27;EQUALS&#x27;:                   { stringFormat: &#x27;{0} eq {1}&#x27; },
      &#x27;NOT_EQUALS&#x27;:               { stringFormat: &#x27;{0} ne {1}&#x27; },
      &#x27;GREATER_THAN&#x27;:             { stringFormat: &#x27;{0} gt {1}&#x27; },
      &#x27;GREATER_THAN_OR_EQUAL_TO&#x27;: { stringFormat: &#x27;{0} ge {1}&#x27; },
      &#x27;LESS_THAN&#x27;:                { stringFormat: &#x27;{0} lt {1}&#x27; },
      &#x27;LESS_THAN_OR_EQUAL_TO&#x27;:    { stringFormat: &#x27;{0} le {1}&#x27; }
    };
  });

  /**
   * Date and time where clause filter class.
   * @class DateTimeFilterOptions
   * @extends FilterOptions
   * @param options {Object} The options object.
   */
  OData.DateTimeFilterOptions = OData._extend(OData.FilterOptions, function(options) {
    this.init(options);
    this.values = {
      &#x27;BEFORE&#x27;:              { stringFormat: &quot;{0} le datetime&#x27;{1}&#x27;&quot; },
      &#x27;AFTER&#x27;:               { stringFormat: &quot;{0} ge datetime&#x27;{1}&#x27;&quot; },
      &#x27;YEAR_EQUALS&#x27;:         { stringFormat: &#x27;year({0}) eq {1}&#x27;     },
      &#x27;MONTH_NUMBER_EQUALS&#x27;: { stringFormat: &#x27;month({0}) eq {1}&#x27;    },
      &#x27;DAY_NUMBER_EQUALS&#x27;:   { stringFormat: &#x27;day({0}) eq {1}&#x27;      },
      &#x27;HOUR_EQUALS&#x27;:         { stringFormat: &#x27;hour({0}) eq {1}&#x27;     },
      &#x27;MINUTE_EQUALS&#x27;:       { stringFormat: &#x27;minute({0}) eq {1}&#x27;   },
      &#x27;SECOND_EQUALS&#x27;:       { stringFormat: &#x27;second({0}) eq {1}&#x27;   }
    };
  });

  /**
   * Gets the where query for DateTime objects.
   * @method getWhereQuery
   * @param propNames {Array|String} The list of property names.
   * @param operator {Array} The type of comparator to perform.
   * @param values {Array|String} The value of the property.
   * @return {String} A DateTime query string.
   */
  OData.DateTimeFilterOptions.prototype.getWhereQuery = function(propNames, operator, values) {
    var query = &#x27;&#x27;,
        val,
        date,
        i,
        validDate = function(value) {
          return (Object.prototype.toString.call(value) === &#x27;[object Date]&#x27;) ? true : false;
        };
    // Take values and convert to ISO string dates
    if (Array.isArray(values)) {
      i = values.length - 1;
      while (i &gt;= 0) {
        val = values[i];
        if (validDate(val)) {
          values[i] = val.toISOString();
        } else {
          date = new Date(val);
          if (validDate(date)) {
            values[i] = date.toISOString();
          } else {
            // Remove the value as it wasn&#x27;t able to convert to a date
            console.error(&#x27;OData.DateTimeFilterOptions.getWhereQuery(): Could not convert &#x27; +
              val.toString() +
              &#x27; to a date. Removing from query&#x27;);
            values.splice(i,1);
          }
        }
        i--;
      }
    } else {
      if (validDate(values)) {
        values = new Date(values).toISOString();
      } else {
        date = new Date(values);
        if (validDate(date)) {
          values = date.toISOString();
        } else {
          // Dropout because &#x60;values&#x60; wasn&#x27;t able to convert to a date
          console.error(&#x27;OData.DateTimeFilterOptions.getWhereQuery(): Could not convert &#x27; +
            values.toString() + &#x27; to a date. Query was not generated.&#x27;);
          return;
        }
      }
    }
    query = OData.DateTimeFilterOptions.base.getWhereQuery.call(
      this, propNames, operator, values);
      return query;
  };

  /**
   * GUID where clause filter class.
   * @class GuidFilterOptions
   * @extends FilterOptions
   * @param options {Object} The options object.
   */
  OData.GuidFilterOptions = OData._extend(OData.FilterOptions, function(options) {
    this.init(options);
    this.values = {
      &#x27;EQUALS&#x27;:     { stringFormat: &quot;{0} eq guid&#x27;{1}&#x27;&quot; },
      &#x27;NOT_EQUALS&#x27;: { stringFormat: &quot;{0} ne guid&#x27;{1}&#x27;&quot; }
    };
  });

  /**
   * String where clause filter class.
   * @class StringFilterOptions
   * @extends FilterOptions
   * @param options {Object} The options object.
   */
  OData.StringFilterOptions = OData._extend(OData.FilterOptions, function(options) {
    this.init(options);
    this.values = {
      &#x27;EQUALS&#x27;:                      { stringFormat: &quot;{0} eq &#x27;{1}&#x27;&quot;                    },
      &#x27;NOT_EQUALS&#x27;:                  { stringFormat: &quot;{0} ne &#x27;{1}&#x27;&quot;                    },
      &#x27;IN_SEMICOLON_SEPARATED&#x27;:      { stringFormat: &quot;{0} eq &#x27;{1}&#x27;&quot;                    },
      &#x27;CASE_INSENSITIVE_EQUALS&#x27;:     { stringFormat: &quot;tolower({0}) eq tolower(&#x27;{1}&#x27;)&quot;  },
      &#x27;CASE_INSENSITIVE_NOT_EQUALS&#x27;: { stringFormat: &quot;tolower({0}) eq tolower(&#x27;{1}&#x27;)&quot;  },
      &#x27;STARTS_WITH&#x27;:                 { stringFormat: &quot;startswith({0}, &#x27;{1}&#x27;) eq true&quot;  },
      &#x27;DOES_NOT_START_WITH&#x27;:         { stringFormat: &quot;startswith({0}, &#x27;{1}&#x27;) eq false&quot; },
      &#x27;ENDS_WITH&#x27;:                   { stringFormat: &quot;endswith({0}, &#x27;{1}&#x27;) eq true&quot;    },
      &#x27;DOES_NOT_END_WITH&#x27;:           { stringFormat: &quot;endswith({0}, &#x27;{1}&#x27;) eq false&quot;   },
      &#x27;CONTAINS&#x27;:                    { stringFormat: &quot;substringof(&#x27;{1}&#x27;, {0}) eq true&quot; },
      &#x27;HAS_LENGTH&#x27;:                  { stringFormat: &quot;length({0}) eq {1}&quot;              }
    };
  });

  /**
   * Gets the where query for String objects.
   * @method getWhereQuery
   * @param propNames {Array|String} The list of property names.
   * @param operator {String} The type of comparator to perform.
   * @param values {Array|String} The value of the property.
   * @return {String} A String query string.
   */
  OData.StringFilterOptions.prototype.getWhereQuery = function(propNames, operator, values) {
    var query = &#x27;&#x27;,
        i,
        l,
        segments,
        finalValue;
    // Perform some sanitization
    if (Array.isArray(values)) {
      for (i=0, l=values.length; i &lt; l; i++) {
        values[i] = String(values[i]).replace(new RegExp(&quot;&#x27;&quot;, &#x27;g&#x27;), &quot;&#x27;&#x27;&quot;);
        if (this.options.encodeUrlComponents) {
          values[i] = encodeURIComponent(values[i]);
        }
      }
    } else {
      values = String(values).replace(new RegExp(&quot;&#x27;&quot;, &#x27;g&#x27;), &quot;&#x27;&#x27;&quot;);
      if (this.options.encodeUrlComponents) {
        values = encodeURIComponent(values);
      }
    }
    if (operator === OData.IN_SEMICOLON_SEPARATED) {
      segments = values.split(&#x27;;&#x27;);
      finalValue = [];
      for (i=0, l=segments.length; i &lt; l; i++) {
        finalValue.push(OData.StringFilterOptions.base.getWhereQuery.call(
          this, propNames, operator, segments[i].trim()));
      }
      query = finalValue.join(&#x27; or &#x27;);
    } else {
      query = OData.StringFilterOptions.base.getWhereQuery.call(
        this, propNames, operator, values);
    }
    return query;
  };

  /**
   * Where clause filter class.
   * @class WhereFilterOptions
   * @param options {Object} The options object.
   */
  OData.WhereFilterOptions = function(options) {
    this.NULL = new OData.NullFilterOptions(options);
    this.BOOLEAN = new OData.BooleanFilterOptions(options);
    this.DECIMAL =
        this.SINGLE =
        this.DOUBLE = new OData.FloatingPointFilterOptions(options);
    this.BYTE =
        this.SBYTE =
        this.INT16 =
        this.INT32 =
        this.INT64 = new OData.IntegerFilterOptions(options);
    this.TIME =
        this.DATE_TIME =
        this.DATE_TIME_OFFSET = new OData.DateTimeFilterOptions(options);
    this.GUID = new OData.GuidFilterOptions(options);
    this.STRING = new OData.StringFilterOptions(options);
  };

  /**
   * Where clause filter class.
   * @method getFilterHandler
   * @param type {String} Type of filter to retrieve.
   * @return {Object} A filter object.
   */
  OData.WhereFilterOptions.prototype.getFilterHandler = function(type) {
    if (this[type]) {
      return this[type];
    } else {
      return this.Null;
    }
  };

  // -----------------------------------------------------------------------------------
  // The query builder class, which knows everything about entities, properties, etc.
  // -----------------------------------------------------------------------------------

  /**
   * Query builder class.
   * @class QueryBuilder
   * @param urlEndpoint {String} The URL of the service endpoint.
   * @param options {Object} The options object.
   */
  OData.QueryBuilder = function(urlEndpoint, options) {
    if (!urlEndpoint) {
      throw &#x27;You must specify the OData service endpoint URL. This should be everything up to the &quot;?&quot;&#x27;;
    }
    this.options = options || {};
    this.baseUrl = OData._cleanEndpointUrl(urlEndpoint);
    this.top = null;
    this.skip = null;
    this.whereFilters = [];
    this.orderBy = [];
    this.filterOptions = new OData.WhereFilterOptions(this.options);
  };

  /**
   * Set the $top value in the final query. If you set val to null,
   * $top will be removed from the final query string.
   * @method setTop
   * @param val {Number} The top value.
   */
  OData.QueryBuilder.prototype.setTop = function(val) {
    this.top = isNaN(parseInt(val)) ? null : parseInt(val);
  };

  /**
   * Set the $skip value in the final query. If you set val to null,
   * $skip will be removed from the final query string.
   * @method setSkip
   * @param val {Number} The skip value.
   */
  OData.QueryBuilder.prototype.setSkip = function(val) {
    this.skip = isNaN(parseInt(val)) ? null : parseInt(val);
  };

  /**
   * Set the $orderby value in the final query. You need to pass the
   * name of the property you want to sort by, and the order of the
   * sort. Valid values are 0, 1, or 2 (NONE, ASC, and DESC respectively).
   * If you pass null, $orderby will be removed from the final query string.
   * @method setOrderBy
   * @param propName {String} The property to order by.
   * @param val {Number} The sort order.
   */
  OData.QueryBuilder.prototype.setOrderBy = function(propName, val) {
    if (propName &amp;&amp; val &amp;&amp; (val === 0 || val === 1 || val === 2)) {
      this.orderBy.push({
        propName: propName,
        value: val
      });
    } else {
      this.orderBy.length = 0;
      console.warn(&#x27;OData.QueryBuilder::setOrderBy(): Missing property name or invalid sort order. $orderBy will be ignored.&#x27;);
    }
  };

  /**
   * Return the base endpoint url.
   * @method getBaseUrl
   * @return {String} The base endpoint url.
   */
  OData.QueryBuilder.prototype.getBaseUrl = function() {
    return this.baseUrl;
  };

  /**
   * Return the final OData query URL.
   * @method generateQueryUrl
   * @return {String} A fully qualified query URL.
   */
  OData.QueryBuilder.prototype.generateQueryUrl = function() {
    var url = this.getBaseUrl(),
        i,
        propertyId,
        propertyName,
        value,
        queryFiltersString,
        sortingOptions = [],
        lastUrlCharIndex;
    url += &#x27;?&#x27;;
    if (this.skip !== undefined &amp;&amp; this.skip !== null) {
      url += &#x27;$skip=&#x27; + this.skip + &#x27;&amp;&#x27;;
    }
    if (this.top !== undefined &amp;&amp; this.top !== null) {
      url += &#x27;$top=&#x27; + this.top + &#x27;&amp;&#x27;;
    }
    if (this.whereFilters &amp;&amp; this.whereFilters.length &gt; 0) {
    //   queryFiltersString = this._getWhereQueryFilter(this.whereFilters);
    //   if (queryFiltersString === undefined) {
    //     throw &#x27;Invalid query filters &#x27; + JSON.stringify(this.whereFilters);
    //   }
      url += &#x27;$filter=&#x27; + this.generateQueryFilterUrl() + &#x27;&amp;&#x27;;
    }
    if (this.orderBy &amp;&amp; this.orderBy.length &gt; 0) {
      url += &#x27;$orderby=&#x27;;
      for (i in this.orderBy) {
        value = this.orderBy[i].value; //0, 1, or 2
        propertyName = this.orderBy[i].propName;
        if (propertyName) {
          switch (value) {
            case 0: {
              // Do not order by this propertyId.
              break;
            }
            case 1: {
              // Sort in asc order.
              sortingOptions.push(propertyName);
              break;
            }
            case 2: {
              // Sort in desc order.
              sortingOptions.push(propertyName + &#x27; desc&#x27;);
              break;
            }
          }
        }
      }
      // Separate the elements with a comma &#x27;,&#x27; and add the &#x27;&amp;&#x27; at the end.
      url += sortingOptions.join() + &#x27;&amp;&#x27;;
    }
    // Remove the &amp; at the end.
    lastUrlCharIndex = url.length - 1;
    if (url[lastUrlCharIndex] === &#x27;&amp;&#x27;) {
      url = url.substring(0, lastUrlCharIndex);
    }
    return url;
  };

  /**
   * Return the filter portion of the OData query URL.
   * @method generateQueryFilterUrl
   * @return {String} The filter URL.
   */
  OData.QueryBuilder.prototype.generateQueryFilterUrl = function() {
    var ret = &#x27;&#x27;;
    if (this.whereFilters &amp;&amp; this.whereFilters.length &gt; 0) {
      var queryFiltersString = this._getWhereQueryFilter(this.whereFilters);
      if (queryFiltersString === undefined) {
        throw &#x27;Invalid query filters &#x27; + JSON.stringify(this.whereFilters);
      }
      ret = queryFiltersString;
    }
    return ret;
  };


  /**
   * Clear the filter list for the OData final query url.
   * @method removeAllWhereFilters
   */
  OData.QueryBuilder.prototype.removeAllWhereFilters = function() {
    this.whereFilters = [];
  };

  /**
   * Add a filter to the list of filter that are used to build a query string.
   * If you call this method multiple times, each filter is AND&#x27;ed together.
   * If propNames or propValues is an array of values, the resulting query
   * string is OR&#x27;ed together for that specific filter.
   * @method addWhereFilter
   * @example
   *    addWhereFilter(OData.STRING, &#x27;FNAME&#x27;, OData.EQUALS, &#x27;bob&#x27;)
   *    addWhereFilter(OData.STRING, &#x27;LNAME&#x27;, OData.EQUALS, &#x27;smith&#x27;)
   * getODataQueryUrl() would return &quot;/api/user/?$filter=FNAME eq &#x27;bob&#x27; and LNAME eq &#x27;smith&#x27;&quot;
   * @example
   *    addWhereFilter(OData.STRING, [&#x27;FNAME&#x27;,&#x27;LNAME&#x27;], OData.EQUALS, [&#x27;bob&#x27;,&#x27;smith&#x27;])
   * getODataQueryUrl() would return &quot;/api/user/?$filter=FNAME eq &#x27;bob&#x27; or LNAME eq &#x27;smith&#x27;&quot;
   * @example
   *    addWhereFilter(OData.STRING, [&#x27;FNAME&#x27;,&#x27;LNAME&#x27;], OData.EQUALS, &#x27;bob&#x27;)
   * getODataQueryUrl() would return &quot;/api/user/?$filter=FNAME eq &#x27;bob&#x27; or LNAME eq &#x27;bob&#x27;&quot;
   * @example
   *    addWhereFilter(OData.STRING, &#x27;FNAME&#x27;, OData.EQUALS, [&#x27;bob&#x27;,&#x27;sam&#x27;])
   * getODataQueryUrl() would return &quot;/api/user/?$filter=FNAME eq &#x27;bob&#x27; or FNAME eq &#x27;sam&#x27;&quot;
   * @param id {String} Unique id for a filter.
   * @param filterType {String} The property filter name(STRING, TIME, DECIMAL, etc).
   * @param propNames {Array|String} A list of property names.
   * @param filterOperator {String} The type of filter(EQUALS, CONTAINS, etc).
   * @param propValues {Array|String} The value for the filter.
   */
  OData.QueryBuilder.prototype.addWhereFilter = function(id, filterType, propNames, filterOperator, propValues) {
    var filter = {
      id: id,
      filterType: filterType,
      propNames: propNames,
      filterOperator: filterOperator,
      propValues: propValues
    };
    // Check if element already exist.
    for (var i = this.whereFilters.length - 1; i &gt;= 0; i--) {
      if (this.whereFilters[i].id === id) {
        // Update.
        this.whereFilters[i] = filter;
        return;
      }
    }
    // Element not found: add a new one.
    this.whereFilters.push(filter);
  };

  /**
   * Delete a specific filter in the filter list.
   * @method removeWhereFilter
   * @param id {String} The id of the filter to remove.
   */
  OData.QueryBuilder.prototype.removeWhereFilter = function(id) {
    for (var i = this.whereFilters.length - 1; i &gt;= 0; i--) {
      // Only doing double equals here because the id could be of type string or number.
      if (this.whereFilters[i].id == id) {
        this.whereFilters.splice(i, 1);
        break;
      }
    }
  };

  /**
   * Return the where filters formatted for the final OData query url.
   * @private
   * @method _getWhereQueryFilter
   * @param whereFilters {Array} A list of all the query filters.
   * @return {Array} The where filters formatted for the final OData query url.
   */
  OData.QueryBuilder.prototype._getWhereQueryFilter = function(whereFilters) {
    var i,
        l,
        filter,
        result = &#x27;&#x27;;
    for (i = 0, l = whereFilters.length; i &lt; l; i++) {
      filter = whereFilters[i];
      result += this.filterOptions.getFilterHandler(filter.filterType).getWhereQuery(
        filter.propNames, filter.filterOperator, filter.propValues);
      if (i &lt; l - 1) {
        result += &#x27; and &#x27;;
      }
    }
    return result;
  };

  return OData;
});

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
